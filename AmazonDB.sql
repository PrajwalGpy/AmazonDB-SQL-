SELECT * FROM category c ;
SELECT * FROM customers c ;
SELECT * FROM inventory i ;
SELECT * FROM order_items oi ;
SELECT * FROM orders o ;
SELECT * FROM payments p ;
SELECT * FROM products p ;
SELECT * FROM sellers s ;
SELECT * FROM shippings s ;


------ null values -----

SELECT
	*
FROM
	shippings s
WHERE
	s."return date" IS NOT NULL;


SELECT
	*
FROM
	orders o
Where
	"order ID" = 14;


SELECT
	*
FROM
	payments p
WHERE
	"order ID" = 14

	
	
	
	
--
--Below are the 20 business problem questions detailed in the sources that the project aims to solve:
--
	
--1.  **Top selling products:** Find the **top 10 selling product** based on the total sale, including the product name, total quantity sold, and the total sale value.
	
--2.  **Revenue by category:** Find each **category and its total revenue**, including the percentage contributions of the total revenue.
	
--3.  **Average order value:** Compute the **average order value**. The calculation must include only customers who have **more than five orders**.
	
--4.  **Monthly sales Trend:** Query the **monthly total sales over the past year**, displaying the sales trend grouping month by month, and returning the current month's sale and the last month's sale.
	
--5.  **Customer with no purchases:** Find the **customers who have registered but never purchased an order**, listing customer details and the time since their registration (though the registration date data was not available in the source tables).
	
--6.  **Best selling categories by state:** Find the **category that is selling the highest** in each state, including the total sales for that category within each state.
	
--7.  **Customers lifetime value (CLV):** Calculate the **total value of orders placed by each customer over their lifetime** and rank customers based on their CLV.
	
--8.  **Inventory stock alert:** Query products where the **stock level is below a certain threshold (less than 10 units)**, including the last restock date and Warehouse ID information

--9.  **Shipping delay questions:** Identify orders where the **shipping date is later than seven days after the order date**, including customer details, order details, and the delivery provider. (Note: The solution implementation later used a threshold of 3 days).
	
--10. **Payment success rate:** Calculate the **percentage of successful payments** across all orders and include a breakdown of payment statuses (fail, success, and refunded).
	
--11. **Top performing sellers:** Find the **top five sellers based on the total sales value**. The challenge includes reporting both successful and failed orders for each seller, and displaying their percentage of successful orders.
	
--12. **Product margin:** Calculate the **profit margin for each product** (the difference between the price and the cost of goods sold). Rank the products by their profit margin, showing the highest to lowest.
	
--13. **Most return product:** Find any product that is being **returned most of the time**. Display the return rate as a percentage of total units sold for each product.
	
--14. **Order pending shipment:** See if any **order has been placed and payment is done but has not been shipped yet**.
--15. **Inactive sellers:** Identify any **sellers who have not made any sales in the last six months**, showing their last sale date and their total sales from the past.
	
--16. **Identify the customers and categorize them into returning or new:** Categorize customers as **returning if they have done more than five returns**, otherwise categorize them as new. Return the customer ID, name, total orders, and total returns.
--17. **Cross selling opportunity:** Determine **cross selling opportunities** (e.g., if customers who bought airports are also buying iPhones).
	
--18. **Top five customers by orders in each state:** Find the **top five customers with the highest number of orders** from each state, including their total sales.
	
--19. **Revenue by shipping providers:** Calculate the **total revenue generated by each shipping provider**, the number of orders handled, and the average delivery time for each provider.
	
--20. **Top 10 product with the highest decreasing Revenue ratio:** Identify the top 10 products where the **revenue has decreased the most compared to the last year** (comparing 2022 Revenue vs. 2023 Revenue).
	
	
	

	
--1.  **Top selling products:** Find the **top 10 selling product** based on the total sale, including the product name, total quantity sold, and the total sale value.
	
----------------------------------------
	
SELECT
	p."product name",
	COUNT(o."order ID" ) as total_quantity_sold ,
	ROUND(SUM(oi."total sale")::numeric, 2) AS total_sale_value
FROM
	orders o
JOIN 
	order_items oi
ON
	o."order ID" = oi."order ID"
join products p 
ON
	oi."product ID" = p."product ID"
GROUP BY
	"product name"
ORDER BY
	3 DESC
LIMIT 10;

---------------------------------------------
--creating the new total sales column

SELECT * FROM order_items oi ;

ALTER  TABLE order_items 
DROP COLUMN  "total sale";

ALTER  TABLE order_items 
add COLUMN  "total sale" float;

UPDATE   order_items oi
SET  "total sale" = quantity * price

---------------------------------------------




--2.  **Revenue by category:** Find each **category and its total revenue**, including the percentage contributions of the total revenue.


----------------------------------------------

SELECT
	c."category name",
	round(SUM(oi."total sale" )::numeric, 2) as Revenue,
	ROUND(
    (
        SUM(oi."total sale")::numeric /
        (SELECT SUM(oi2."total sale")::numeric FROM order_items oi2)
    ) * 100
, 2) AS revenue_percentage
FROM
	order_items oi
JOIN products p 
ON
	oi."product ID" = p."product ID"
LEFT JOIN category c 
ON
	p."category ID" = c."category ID"
GROUP BY
	1
ORDER BY 
	2 DESC ;



---------------------------------------------------



--3.  **Average order value:** Compute the **average order value**. The calculation must include only customers who have **more than five orders**.
	


--------------------------------------------------------------

SELECT
	c."customer ID" ,
	concat(c."first name" , ' ', c."last name" ),
	round((SUM(oi."total sale" )/ count(o."order ID" ))::numeric, 2) as AVG_price,
	count(o."order ID") as total_orders
FROM
	customers c
JOIN orders o 
ON
	c."customer ID" = o."customer ID"
JOIN order_items oi 
ON
	o."order ID" = oi."order ID"
GROUP BY
	1
HAVING
	count(o."order ID") > 5;




--------------------------------------------------------------



--4.  **Monthly sales Trend:** Query the **monthly total sales over the past year**, displaying the sales trend grouping month by month, and returning the current month's sale and the last month's sale.


--------------------------------------------------------------


SELECT
	t1.year,
	t1.month,
	t1."total sale" as current_month_sale,
	lag(t1."total sale") OVER(order by t1.year, t1.month) as last_month_sale, 
	(t1."total sale" - LAG(t1."total sale") OVER (
	ORDER BY t1.year,
	t1.month)) AS dep
FROM
	(
	SELECT
		extract(month from o."order date" ) as month,
		EXtract(year from o."order date") as year,
		round(sum(oi."total sale")::numeric, 2) as "total sale"
	from
		orders o
	join order_items oi 
ON
		o."order ID" = oi."order ID"
	where
		o."order date"::date >= CURRENT_DATE - interval '2 year'
	group by
		1,
		2
	order by
		year,
		month
) as t1
ORDER BY
	year,
	month;



--------------------------------------------------------------


--5.  **Customer with no purchases:** Find the **customers who have registered but never purchased an order**, listing customer details and the time since their registration (though the registration date data was not available in the source tables).


SELECT
	*
From
	customers c
left join orders o 
ON
	c."customer ID" = o."customer ID"
where
	o."order ID" is NULL ;

--------------------------------------------

SELECT
	*
from
	customers c
where
	c."customer ID" not in( SELECT DISTINCT o."customer ID" from orders o );


--------------------------------------------




--6.  **Best selling categories by state:** Find the **category that is selling the highest** in each state, including the total sales for that category within each state.



------------------------------------------------------------

SELECT
	t1."category name",
	t1.state,
	round(t1.total_sales::numeric, 2) as total_sales
from
	(
	SELECT
		c2."category name",
		c.state,
		SUM(oi."total sale" ) as total_sales,
		RANK() OVER (PARTITION BY c.state
	ORDER BY
		SUM(oi."total sale") DESC) AS ranking
	from
		customers c
	join orders o 
on
		c."customer ID" = o."customer ID"
	JOIN order_items oi 
ON
		o."order ID" = oi."order ID"
	join products p 
on
		oi."product ID" = p."product ID"
	join category c2 
on
		p."category ID" = c2."category ID"
	group by
		2,
		1
) as t1
where
	ranking = 1 ;
	
	
	
------------------------------------------------------------


	
	
--7.  **Customers lifetime value (CLV):** Calculate the **total value of orders placed by each customer over their lifetime** and rank customers based on their CLV.
	
	
	
	
------------------------------------------------------------

SELECT
	c."customer ID",
	concat(c."first name" , ' ', c."last name" ) as Customers_name,
	round(sum(oi."total sale" )::numeric, 2) as CLV,
	dense_rank() over(order by round(sum(oi."total sale" )::numeric, 2) desc) as Customers_rank
FROM
	customers c
join orders o  
	on
	c."customer ID" = o."customer ID"
join order_items oi 
	on
	o."order ID" = oi."order ID"
join payments p 
	on
	o."order ID" = p."order ID"
WHERE
	p."payment status" != 'refunded'
GROUP by
	c."customer ID"
ORDER BY
	3 desc ;

------------------------------------------------------------


--8.  **Inventory stock alert:** Query products where the **stock level is below a certain threshold (less than 10 units)**, including the last restock date and Warehouse ID information

------------------------------------------------------------


SELECT
	i."product ID" ,
	i."Warehouse ID" ,
	p."product name" ,
	i.stock ,
	i."last stock date"
FROM
	inventory i
join products p 
on
	i."product ID" = p."product ID"
where
	i.stock < 10 ;


------------------------------------------------------------



--9.  **Shipping delay questions:** Identify orders where the **shipping date is later than seven days after the order date**, including customer details, order details, and the delivery provider. (Note: The solution implementation later used a threshold of 3 days).



------------------------------------------------------------
SELECT * from customers c 

SELECT
	o."order ID",
	concat(c."first name", ' ', c."last name" ) as customer_name,
	c."customer ID" ,
	s."shipping providers",
	o."order date"::date AS order_date,
	s."shipping date"::date AS shipping_date,
	(s."shipping date" ::date - o."order date"::date) as delay_days
FROM
	shippings s
join orders o 
on
	s."order ID" = o."order ID"
join customers c 
on
	c."customer ID" = o."customer ID"
where 
	(s."shipping date" ::date - o."order date"::date) > 7;



--------------------------------------------------------------------


--10. **Payment success rate:** Calculate the **percentage of successful payments** across all orders and include a breakdown of payment statuses (fail, success, and refunded).


--------------------------------------------------------------------

with cat as (
SELECT
	t."payment status",
	t.total_taransaction
FROM
	(
	SELECT
		p."payment status",
		count(*) as Total_taransaction
	FROM
		payments p
	Group by
		"payment status"
)as t
group by
	1,
	2
	)
SELECT
	cat."payment status" as t2,
	cat.total_taransaction,
	round(
			((sum(cat.total_taransaction)/
			(Select sum(c2.total_taransaction) from cat as c2)::numeric)* 100), 2
		) as p_total_taransaction
from
	cat
GROUP BY
	1,
	2
ORDER By
	3
DESC ;


---------------------------------------------------

SELECT
	p."payment status" ,
	count(*) as Total_count,
	round((count(*)::numeric /(select Count(*) from payments p2 )::numeric * 100), 2) as p_total_taransaction
From
	payments p
join orders o 
on
	p."order ID" = o."order ID"
GROUP BY
	1;



----------------------------------------------------


--11. **Top performing sellers:** Find the **top five sellers based on the total sales value**. The challenge includes reporting both successful and failed orders for each seller, and displaying their percentage of successful orders.


----------------------------------------------------------

with top_5_sellers as ( 
SELECT
	o."seller ID" ,
	oi."total sale",
	s."seller name" 
FROM
	sellers s
join orders o 
on
	s."seller ID" = o."seller ID"
join order_items oi 
on
	o."order ID" = oi."order ID"
join payments p 
on
	p."order ID" = oi."order ID"
GROUP BY 
	1,
	2,3
ORDER By
	oi."total sale" DESC
LIMIT 5 
),

Seller_Report as (

Select
	o."seller ID" ,
	o."order status" ,
	ts."total sale",
	ts."seller name",
	count(*) as total_orders
From
	orders o
join top_5_sellers as ts
on
	o."seller ID" = ts."seller ID"
where
	o."order status" not in ('processing', 'shipped', 'returned')
GROUP By
	1,
	2,
	3,
	4


)

SELECT
	s."seller ID",
	s."seller name",
	sum(case when s."order status" = 'delivered' then s.total_orders else 0 end) as successful_orders,
	sum(case when s."order status" = 'cancelled' then s.total_orders else 0 end) as failed_orders,
	sum(s.total_orders) as total_orders,
	round(
			(sum
				(case when s."order status" = 'delivered' then s.total_orders else 0 end)::numeric / 					sum(s.total_orders)::numeric)* 100, 2
		) as per_of_successful_orders
from
	Seller_Report as s
group by
	1,
	2
ORDER By
	1  
;



-------------------------------------------------------------------------


--12. **Product margin:** Calculate the **profit margin for each product** (the difference between the price and the cost of goods sold). Rank the products by their profit margin, showing the highest to lowest.


--------------------------------------------------------------------------



SELECT
	p."product ID" ,
	p."product name" ,
	round(sum(oi."total sale" -(p.cogs * oi.quantity ))::numeric, 2) as profit,
	round(sum(oi."total sale" -(p.cogs * oi.quantity ))::numeric / sum(oi."total sale")::numeric * 100, 2) as profit_margin,
	dense_rank() over(order by sum(oi."total sale" -(p.cogs * oi.quantity ))::numeric / sum(oi."total sale")::numeric * 100 desc) as margin_rank
FROM  
	order_items oi
join products p 
on
	oi."product ID" = p."product ID"
group by
	1,
	2 ;


--------------------------------------------------------------------------


--13. **Most return product:** Find any product that is being **returned most of the time**. Display the return rate as a percentage of total units sold for each product.


--------------------------------------------------------------------------

SELECT
	oi."product ID" ,
	count(*),
	SUM(CASE WHEN o."order status" = 'returned' THEN 1 ELSE 0 END) AS returned_items,
	ROUND(
    (SUM(CASE WHEN o."order status" = 'returned' THEN 1 ELSE 0 END)::numeric
     / NULLIF(COUNT(*), 0)) * 100
  , 2) AS return_rate_pct
From
	orders o
join order_items oi 
on
	o."order ID" = oi."order ID"
group by
	1
ORDER by
	3 desc;

--------------------------------------------------------------------------


--14. **Order pending shipment:** See if any **order has been placed and payment is done but has not been shipped yet**.


--------------------------------------------------------------------------

SELECT
	o."customer ID" ,
	o."order ID" ,
	o."order status" ,
	p."payment ID" ,
	p."payment status" ,
	s."delivery status" ,
	s."shipping date"
from
	orders o
join shippings s 
on
	o."order ID" = s."order ID"
join payments p 
on
	o."order ID" = p."order ID"
WHERE
	o."order status" = 'processing'
	and p."payment status" = 'confirmed'
	
	
	
--------------------------------------------------------------------------
	
	
--15. **Inactive sellers:** Identify any **sellers who have not made any sales in the last six months**, showing their last sale date and their total sales from the past.

	
--------------------------------------------------------------------------
	
SELECT
	*
from
	sellers s
where
	s."seller ID" not in (
	Select
		o."seller ID"
	from
		orders o
	where
		o."order date" >= current_date - interval '18 month')
;



--------------------------------------------------------------------------

--16. **Identify the customers and categorize them into returning or new:** Categorize customers as **returning if they have done more than five returns**, otherwise categorize them as new. Return the customer ID, name, total orders, and total returns.


--------------------------------------------------------------------------

SELECT
	t.*,
	CASE
		when t.return_ord > 5 then 'return cust'
		else 'new'
	end
FROM
	(
	SELECT
		c."customer ID" ,
		concat(c."first name" , ' ', c."last name" ) as cust_name,
		count(*) as total_orders,
		sum(case 
		when o."order status" = 'returned' then 1 else 0 
	end ) as return_ord
	from
		orders o
	join order_items oi 
		on
		o."order ID" = oi."order ID"
	join customers c 
		on
		c."customer ID" = o."customer ID"
	GROUP By
		1
	ORDER by 
		4 desc,
		3 desc) as t ;


-----------------------------------------------------------------	

--17. **Cross selling opportunity:** Determine **cross selling opportunities** (e.g., if customers who bought airports are also buying iPhones).


---------------------------------------------------------------------




---------------------------------------------------------------------------


--18. **Top five customers by orders in each state:** Find the **top five customers with the highest number of orders** from each state, including their total sales.

-------------------------------------------------------------------------------

with top_5_cust as (
select
	c."customer ID" ,
	c.state ,
	sum(oi."total sale") as total_sales,
	concat(c."first name" , ' ', c."last name" ) as cust_name,
	count(distinct o."order ID") as total_orders
from
	customers c
join orders o 
on
	c."customer ID" = o."customer ID"
join order_items oi 
on
	oi."order ID" = o."order ID"
group by
	1,
	2
)
select
	t."customer ID",
	t.state,
	t.cust_name,
	t.total_orders,
	round(t.total_sales::numeric, 2) as total_sales
from
	(
	select
		*,
		row_number() over(partition by t2.state order by t2.total_orders desc, t2.total_sales desc)as rn
	from
		top_5_cust as t2) t
where
	rn <= 5
order by
	2 ,
	t.total_orders desc,
	total_sales desc
	
;

------------------------------------------------------------------------------



--19. **Revenue by shipping providers:** Calculate the **total revenue generated by each shipping provider**, the number of orders handled, and the average delivery time for each provider.


--------------------------------------------------------------------------------

select
	sp."shipping providers" ,
	count(distinct o."order ID" ) as total_orders,
	round(SUM(oi."total sale" )::numeric, 2) as total_sale,
	round(AVG(sp."return date" - sp."shipping date" )::numeric, 2) as Avg_days
from
	orders o
join order_items oi 
on
	o."order ID" = oi."order ID"
join shippings sp
on
	o."order ID" = sp."order ID"
group by
	1 ;



-------------------------------------------------------------------------------------


--20. **Top 10 product with the highest decreasing Revenue ratio:** Identify the top 10 products where the **revenue has decreased the most compared to the last year** (comparing 2023 Revenue vs. 2024 Revenue).

	
-------------------------------------------------------------------------------------
with prev_year_revenue as(
select
	p."product ID" ,
	p."product name" ,
	SUM(oi."total sale" ) as revenue
from
	orders o
join order_items oi 
on
	o."order ID" = oi."order ID"
join products p 
on
	oi."product ID" = p."product ID"
where extract(year from o."order date" ) = 2023
group by 1, 2
),
current_year_revenue as
(
select
	p."product ID" ,
	p."product name" ,
	SUM(oi."total sale" ) as revenue
from
	orders o
join order_items oi 
on
	o."order ID" = oi."order ID"
join products p 
on
	oi."product ID" = p."product ID"
where
	extract(year from o."order date" ) = 2024
group by
	1,
	2)
select
	cy."product ID" ,
	cy."product name" ,
	round(py.revenue::numeric, 2) revenue_2023,
	ROUND(coalesce(cy.revenue , 0)::numeric, 2) as revenue_2024,
	(py.revenue - cy.revenue ) as revenue_deff,
	round((py.revenue - coalesce(cy.revenue , 0))::numeric / py.revenue::numeric * 100, 2) as revenue_deff_per
from
	prev_year_revenue py
join current_year_revenue cy
on
	cy."product ID" = py."product ID"
where
	py.revenue > cy.revenue
order by
	revenue_deff_per desc
limit 10;


--------------------------------------------------------------------



--The last problem solved in the Advanced SQL Data Analysis project is Business Problem 20, which involves the creation of a **Store Procedure**. The purpose of this procedure is to **automatically update the stock quantity in the inventory table** as soon as a new sales record is inserted.
--
--This process requires performing multiple steps in a single transaction block: checking stock, inserting data into the `orders` and `order_items` tables, and finally updating the `inventory` table.
--
--The procedure is named `add_sales` and uses PostgreSQL's procedural language (PL/pgSQL).
--
--### SQL Code for the Stored Procedure (Automatic Inventory Update)
--
--```sql
-- SQL Solution for Business Problem 20: Automatic Inventory Update Stored Procedure

create or replace
procedure add_sales(
    p_order_id INT, -- Order ID entered by user
p_customer_id INT, -- Customer ID
p_seller_id INT, -- Seller ID
p_order_item_id INT, -- Order Item ID
p_product_id INT, -- Product ID being purchased
p_quantity INT -- Quantity requested by the customer
)
language plpgsql
-- Mandatory for PostgreSQL procedures
as $$
declare
    v_count INT;
-- Variable to store the count of available stock/products
v_price FLOAT;
-- Variable to store the price per unit fetched from products table
v_product VARCHAR(50);
-- Variable to store the product name (VARCHAR 50 is used in declaration)
begin
-- Fetching product price and name based on the input product ID
    select
	price,
	"product name"
into
	v_price,
	v_product
from
	products
where
	"product ID" = p_product_id;
-- Checking product availability and if current stock is sufficient
    select
	COUNT(*)
into
	v_count
from
	inventory
where
	"product ID" = p_product_id
	and stock >= p_quantity;

if v_count > 0 then
-- If stock is available (v_count > 0)
-- 1. Insert record into orders table
        insert
	into
	orders ("order ID",
	"order date",
	"customer ID",
	"seller ID")
values (p_order_id,
CURRENT_DATE,
p_customer_id,
p_seller_id);
-- 2. Insert record into order_items table
        insert
	into
	order_items ("order item ID",
	"order ID",
	"product ID",
	quantity,
	price,
	"total sale")
values (p_order_item_id,
p_order_id,
p_product_id,
p_quantity,
v_price,
v_price * p_quantity);
-- 3. Update inventory table (reducing stock by purchased quantity)
        update
	inventory
set
	stock = stock - p_quantity
where
	"product ID" = p_product_id;
-- Success message
        raise notice 'Thank you! Product % sale has been added, and inventory stock updated.',
v_product;
else
-- If stock is not sufficient
-- Failure message
        raise notice 'Thank you for your info. Product % is not available at the moment.',
v_product;
end if;
end;

$$;



call add_sales(
    250025, -- p_order_id
    2, -- p_customer_id
    5, -- p_seller_id
    250035, -- p_order_item_id
    1, -- p_product_id 
    60 -- p_quantity 
);

select * from inventory i
where i."product ID" = 1
